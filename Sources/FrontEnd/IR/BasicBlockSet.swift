/// A set of basic block identities.
public struct BasicBlockSet: Hashable, Sendable {

  /// The internal representation of the set.
  ///
  /// The array notionally encodes a map `[BasicBlock.ID: Bool]`, using positions as keys. The
  /// efficiency of this representation relies on the assumption that basic block identities are
  /// generated by increasing a counter starting from 0.
  ///
  /// For each entry, the value is encoded using the least significant bit. We use `Int8` rather
  /// than `Bool` to simplify the implementation of symmetric difference.
  private var storage: [Int8]

  /// Creates an empty set.
  public init() {
    self.storage = []
  }

  /// Reserve enough memory to store `b` elements without allocating new memory.
  private mutating func reserveCapacity(_ k: Int) {
    storage.append(contentsOf: repeatElement(0, count: k - storage.count + 1))
  }

}

extension BasicBlockSet: SetAlgebra {

  public typealias Element = BasicBlock.ID

  public var isEmpty: Bool {
    storage.isEmpty
  }

  public func contains(_ b: BasicBlock.ID) -> Bool {
    b < storage.count ? (storage[b] != 0) : false
  }

  @discardableResult
  public mutating func insert(
    _ b: BasicBlock.ID
  ) -> (inserted: Bool, memberAfterInsert: BasicBlock.ID) {
    if b >= storage.count { reserveCapacity(b) }
    defer { storage[b] = 1 }
    return (inserted: storage[b] == 0, memberAfterInsert: b)
  }

  @discardableResult
  public mutating func remove(_ b: BasicBlock.ID) -> BasicBlock.ID? {
    if b < storage.count { storage[b] = 0 }
    return b
  }

  @discardableResult
  public mutating func update(with b: BasicBlock.ID) -> BasicBlock.ID? {
    insert(b).memberAfterInsert
  }

  public mutating func formUnion(_ other: BasicBlockSet) {
    var i = 0
    while true {
      if (i < self.storage.count) && (i < other.storage.count) {
        self.storage[i] = self.storage[i] | other.storage[i]
        i += 1
      } else {
        self.storage.append(contentsOf: other.storage.dropFirst(i))
        return
      }
    }
  }

  public func union(_ other: BasicBlockSet) -> BasicBlockSet {
    var clone = self
    clone.formUnion(other)
    return clone
  }

  public mutating func formIntersection(_ other: BasicBlockSet) {
    var i = 0
    while true {
      if (i < self.storage.count) && (i < other.storage.count) {
        self.storage[i] = self.storage[i] & other.storage[i]
        i += 1
      } else {
        self.storage.removeLast(max(0, self.storage.count - other.storage.count))
        return
      }
    }
  }

  public func intersection(_ other: BasicBlockSet) -> BasicBlockSet {
    var clone = self
    clone.formIntersection(other)
    return clone
  }

  public mutating func formSymmetricDifference(_ other: __owned BasicBlockSet) {
    var i = 0
    while true {
      if (i < self.storage.count) && (i < other.storage.count) {
        self.storage[i] = self.storage[i] ^ other.storage[i]
        i += 1
      } else {
        self.storage.append(contentsOf: other.storage.dropFirst(i))
        return
      }
    }
  }

  public func symmetricDifference(_ other: BasicBlockSet) -> BasicBlockSet {
    var clone = self
    clone.formSymmetricDifference(other)
    return clone
  }

}

extension BasicBlockSet: CustomStringConvertible {

  public var description: String {
    storage
      .enumerated()
      .compactMap({ (i, b) in (b != 0) ? BasicBlock.ID(i) : nil })
      .description
  }

}
