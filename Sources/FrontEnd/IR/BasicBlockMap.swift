/// An associative array whose keys are basic block identities.
public struct BasicBlockMap<Value> {

  /// The internal representation of the map.
  ///
  /// The array notionally encodes a map `[BasicBlock.ID: Value]`, using positions as keys. The
  /// efficiency of this representation relies on the assumption that basic block identities are
  /// generated by increasing a counter starting from 0.
  private var storage: [Value?]

  /// Creates an empty map.
  public init() {
    self.storage = []
  }

  /// Accesses the value associated with `b`.
  public subscript(b: BasicBlock.ID) -> Value? {
    get {
      (b < storage.count) ? storage[b] : nil
    }
    _modify {
      if b >= storage.count {
        storage.append(contentsOf: repeatElement(nil, count: b - storage.count))
      }
      yield &storage[b]
    }
  }

  /// Accesses the value associated with `b` or projects `v` if `b` is not assigned.
  public subscript(b: BasicBlock.ID, default v: @autoclosure () -> Value) -> Value {
    get {
      ((b < storage.count) ? storage[b] : nil) ?? v()
    }
    _modify {
      if b >= storage.count {
        storage.append(contentsOf: repeatElement(nil, count: b - storage.count))
      }
      var w = storage[b] ?? v()
      defer { storage[b] = w }
      yield &w
    }
  }

}

extension BasicBlockMap: BidirectionalCollection {

  public typealias Element = (key: BasicBlock.ID, value: Value)

  public typealias Index = Int

  public var isEmpty: Bool {
    storage.isEmpty || (startIndex == endIndex)
  }

  public var startIndex: Int {
    storage.firstIndex(where: { (v) in v != nil }) ?? endIndex
  }

  public var endIndex: Int {
    storage.count
  }

  public func index(after i: Int) -> Int {
    storage[i...].firstIndex(where: { (v) in v != nil }) ?? endIndex
  }

  public func index(before i: Int) -> Int {
    storage[..<i].lastIndex(where: { (v) in v != nil })!
  }

  public subscript(i: Int) -> (key: BasicBlock.ID, value: Value) {
    (BasicBlock.ID(i), storage[i]!)
  }

}

extension BasicBlockMap: Equatable where Value: Equatable {}

extension BasicBlockMap: Hashable where Value: Hashable {}

extension BasicBlockMap: Sendable where Value: Sendable {}

extension BasicBlockMap: CustomStringConvertible {

  public var description: String {
    storage
      .enumerated()
      .compactMap({ (k, v) in v.map({ "\(BasicBlock.ID(k)): \($0)" }) })
      .description
  }

}
